#region

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using nadena.dev.ndmf.preview;
using nadena.dev.ndmf.runtime;
using UnityEditor;
using UnityEngine;

#endregion

namespace nadena.dev.ndmf
{
    /// <summary>
    /// Provides information about VRChat Expression Parameters and animator parameters generated by NDMF-registered
    /// components. 
    /// </summary>
    public sealed class ParameterInfo
    {
        public static readonly ParameterInfo ForUI = new((BuildContext)null);

        public static ParameterInfo ForContext(BuildContext context)
        {
            return context.GetState(ctx => new ParameterInfo(ctx));
        }

        public static ParameterInfo ForPreview(ComputeContext context)
        {
            return new ParameterInfo(context);
        }

        private readonly BuildContext _context;
        private readonly ComputeContext _computeContext;

        public enum ConflictType
        {
            TypeMismatch
        }

        /// <summary>
        /// Invoked when multiple components provide a parameter with the same name, but with conflicting configuration.
        /// May be invoked multiple times for different conflict types. 
        /// </summary>
        public delegate void ConflictHandler(ConflictType type, ProvidedParameter p1, ProvidedParameter p2);

        [InitializeOnLoadMethod]
        static void Init()
        {
            EnhancerDatabase<ParameterProviderFor, IParameterProvider>.AsyncInit();
        }

        private ParameterInfo(BuildContext context)
        {
            _context = context;
            _computeContext = ComputeContext.NullContext;
        }

        private ParameterInfo(ComputeContext ctx)
        {
            _computeContext = ctx;
        }

        private long _parameterCount; // used to maintain declaration order

        private struct RegisteredParameter
        {
            public ProvidedParameter Parameter;
            public long index;
        }

        /// <summary>
        /// Enumerates a GameObject and all children, querying for components which provide parameters, and returns what
        /// was found.
        /// </summary>
        /// <param name="obj">The object to query</param>
        /// <param name="onConflict">A callback to receive information about conflicting values.</param>
        /// <returns></returns>
        public IEnumerable<ProvidedParameter> GetParametersForObject(GameObject obj, ConflictHandler onConflict = null)
        {
            _parameterCount = 0;
            // Unity 2019 will break if we take any of ReSharper's suggestions here...
            
            // ReSharper disable InconsistentNaming
            // ReSharper disable UnusedParameter.Local
            // ReSharper disable ConvertToNullCoalescingCompoundAssignment
            onConflict = onConflict ?? ((_type, _p1, _p2) => { });
            // ReSharper restore ConvertToNullCoalescingCompoundAssignment
            // ReSharper restore UnusedParameter.Local
            // ReSharper restore InconsistentNaming

            return GetParametersForObject(obj, onConflict,
                    ImmutableDictionary<(ParameterNamespace, string), ParameterMapping>.Empty)
                .OrderBy(rp => rp.index)
                .Select(rp => rp.Parameter);
        }

        /// <summary>
        /// Determines what parameter name remappings are effective at a given game object. 
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> GetParameterRemappingsAt(
            GameObject obj)
        {
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> mappings
                = ImmutableDictionary<(ParameterNamespace, string), ParameterMapping>.Empty;

            if (!RuntimeUtil.IsAvatarRoot(obj.transform) && obj.transform.parent != null)
            {
                _computeContext.ObservePath(obj.transform);
                mappings = GetParameterRemappingsAt(obj.transform.parent.gameObject);
            }

            foreach (var component in _computeContext.GetComponents(obj, typeof(Component)))
            {
                if (EnhancerDatabase<ParameterProviderFor, IParameterProvider>.Query(component, out var provider))
                {
                    _computeContext.Observe(component); // TODO: Can we add an extract condition here?
                    provider.RemapParameters(ref mappings, _context);
                }
            }

            return mappings;
        }

        /// <summary>
        /// Determines what parameter name remappings are effective at a given component (including any mappings applied
        /// by siblings).
        /// </summary>
        /// <param name="c"></param>
        /// <param name="includeSelf">Include component c's mappings in the result</param>
        /// <returns></returns>
        public ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> GetParameterRemappingsAt(Component c,
            bool includeSelf)
        {
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> mappings
                = ImmutableDictionary<(ParameterNamespace, string), ParameterMapping>.Empty;

            if (!RuntimeUtil.IsAvatarRoot(c.transform))
            {
                _computeContext.ObservePath(c.transform);
                mappings = GetParameterRemappingsAt(c.transform.parent.gameObject);
            }

            foreach (var component in _computeContext.GetComponents(c.gameObject, typeof(Component)))
            {
                if (component == c && !includeSelf)
                {
                    break;
                }

                if (EnhancerDatabase<ParameterProviderFor, IParameterProvider>.Query(component, out var provider))
                {
                    _computeContext.Observe(component); // TODO: Can we add an extract condition here?
                    provider.RemapParameters(ref mappings, _context);
                }

                if (component == c) break;
            }

            return mappings;
        }

        private IEnumerable<RegisteredParameter> GetParametersForObject(GameObject root, ConflictHandler onConflict,
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> remaps)
        {
            Dictionary<(ParameterNamespace, string), RegisteredParameter> parameters
                = new Dictionary<(ParameterNamespace, string), RegisteredParameter>();

            foreach (var component in _computeContext.GetComponents(root, typeof(Component)))
            {
                if (!EnhancerDatabase<ParameterProviderFor, IParameterProvider>.Query(component, out var provider))
                {
                    continue;
                }

                _computeContext.Observe(component); // TODO: Can we add an extract condition here?

                // Apply mappings first
                provider.RemapParameters(ref remaps, _context);

                // Collect parameters
                foreach (var newParameter in provider.GetSuppliedParameters(_context))
                {
                    if (remaps.TryGetValue(newParameter.NamePair, out var singleRemap))
                    {
                        newParameter.EffectiveName = singleRemap.ParameterName;
                        newParameter.IsHidden = newParameter.IsHidden || singleRemap.IsHidden;
                    }

                    if (parameters.TryGetValue(newParameter.NamePair, out var existingParam))
                    {
                        ResolveConflict(existingParam.Parameter, newParameter, onConflict);
                    }
                    else
                    {
                        parameters[newParameter.NamePair] = new RegisteredParameter
                        {
                            Parameter = newParameter,
                            index = _parameterCount++
                        };
                    }
                }
            }

            Dictionary<(ParameterNamespace, string), RegisteredParameter> childParameters = CollectChildParams(root, onConflict, remaps);

            foreach (var kvp in childParameters)
            {
                if (parameters.TryGetValue(kvp.Key, out var existingParam))
                {
                    ResolveConflict(existingParam.Parameter, kvp.Value.Parameter, onConflict);
                }
                else
                {
                    parameters[kvp.Key] = kvp.Value;
                }
            }

            return parameters.Values;
        }

        private Dictionary<(ParameterNamespace, string), RegisteredParameter> CollectChildParams(GameObject root, ConflictHandler onConflict,
            ImmutableDictionary<(ParameterNamespace, string), ParameterMapping> remaps)
        {
            Dictionary<(ParameterNamespace, string), RegisteredParameter> parameters = new Dictionary<(ParameterNamespace, string), RegisteredParameter>();

            foreach (Transform childTransform in root.transform)
            {
                if (childTransform.gameObject.CompareTag("EditorOnly"))
                {
                    continue;
                }
                
                var childParams = GetParametersForObject(childTransform.gameObject, onConflict, remaps);

                foreach (var rp in childParams)
                {
                    if (parameters.TryGetValue(rp.Parameter.NamePair, out var existingParam))
                    {
                        ResolveConflict(existingParam.Parameter, rp.Parameter, onConflict);
                    }
                    else
                    {
                        parameters[rp.Parameter.NamePair] = rp;
                    }
                }
            }

            return parameters;
        }

        private void ResolveConflict(ProvidedParameter oldP, ProvidedParameter newP, ConflictHandler onConflict)
        {
            ResolveParameterType(oldP, newP, onConflict);

            oldP.IsAnimatorOnly &= newP.IsAnimatorOnly;
            oldP.IsHidden &= newP.IsHidden;
            oldP.WantSynced |= newP.WantSynced;
            oldP.DefaultValue ??= newP.DefaultValue;
        }

        private void ResolveParameterType(ProvidedParameter oldP, ProvidedParameter newP, ConflictHandler onConflict)
        {
            if ((oldP.ParameterType == newP.ParameterType) ||
                (oldP.ParameterType != null && newP.ParameterType == null) ||
                (oldP.ParameterType != null && newP.IsAnimatorOnly))
            {
                return;
            }

            if (oldP.ParameterType == null ||
                oldP.IsAnimatorOnly)
            {
                oldP.ParameterType = newP.ParameterType;
                return;
            }

            if (!oldP.ExpandTypeOnConflict ||
                !newP.ExpandTypeOnConflict)
            {
                onConflict(ConflictType.TypeMismatch, oldP, newP);
                return;
            }

            if (oldP.ParameterType == AnimatorControllerParameterType.Bool ||
                newP.ParameterType == AnimatorControllerParameterType.Float)
            {
                oldP.ParameterType = newP.ParameterType;
                return;
            }
        }
    }
}